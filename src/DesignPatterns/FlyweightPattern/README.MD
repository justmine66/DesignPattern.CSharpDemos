# 享元模式(Flyweight)
>运用共享技术有效地支持大量细粒度的对象。
# 内部状态与外部状态
>在享元对象内部并不会随环境改变而改变的共享部分，可以称之为享元对象的内部状态，而随环境改变而改变的、不可以共享的状态称之为外部状态。事实上，**享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生产大量细粒度的实例来表示数据。如果发现这些实例除了几个参数外基本上都是相同的，有时就能够大幅度的减少实例化的类的数量。如果能把那些参数迁移到类实例的外面，在方法调用的时将它们传递进来，就可以大幅度地减少单个实例的数目**。也就是说享元模式，执行时的状态是有内部的也有外部的，内部状态存储于ConcreteFlyweight中，而外部对象则应该考虑由客户端对象存储和计算，当调用Flyweight对象的操作时，将该状态传递给它。
# 应用场景
>如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
# 总结
>享元模式更多地是一种底层的设计模式
>在某些情况下，对象的数量可能会太多，从而导致运行时的资源与性能损耗。那么我们如何去避免大量细粒度的对象，同时又不影响客户程序，是一个值得去思考的问题，享元模式，可以运用共享技术有效地支持大量细粒度的对象。不过，你也别高兴的太早，使用 享元模式维护了一个记录系统所有享元的列表，而本身也是需要耗费资源的，另外享元模式让系统更加复杂。为了使对象可以共享，需要做一些状态外部化，这使得程序的逻辑复杂化。因此，应当在足够多的对象实例可共享时才值得使用享元模式。
# 示例场景
>项目多也别傻做